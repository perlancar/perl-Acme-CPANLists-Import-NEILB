#!/usr/bin/env perl

use 5.010;
use strict;
use warnings;
use Log::Any::App '$log';

use CPAN::Module::FromURL qw(extract_module_from_cpan_url);
use Data::Dmp;
use File::Slurper qw(read_text write_text);
use FindBin '$Bin';
use LWP::UserAgent;
use DOM::Tiny;

my $now = time();

my @modules = (
    {
        name => 'Markdown',
        url => 'http://neilb.org/reviews/markdown.html',
        summary => 'Modules for converting markdown to HTML',
    },
    {
        name => 'ModuleLoading',
        url => 'http://neilb.org/reviews/module-loading.html',
        summary => 'Modules that (can) load other modules',
    },
    {
        name => 'ModulePath',
        url => 'http://neilb.org/reviews/module-path.html',
        summary => q(Getting a module's path),
    },
    {
        name => 'LUHN',
        url => 'http://neilb.org/reviews/luhn.html',
        summary => 'Checking credit card numbers (LUHN check)',
    },
    {
        name => 'HTTPRequesters',
        url => 'http://neilb.org/reviews/http-requesters.html',
        summary => 'Making HTTP requests',
    },
    {
        name => 'Dependencies',
        url => 'http://neilb.org/reviews/dependencies.html',
        summary => 'Getting module dependency information',
    },
    {
        name => 'Constants',
        url => 'http://neilb.org/reviews/constants.html',
        summary => 'Defining constants',
    },
    {
        name => 'UserAgent',
        url => 'http://neilb.org/reviews/user-agent.html',
        summary => 'Parsing User-Agent strings',
    },
    {
        name => 'SpellNumbers',
        url => 'http://neilb.org/reviews/spell-numbers.html',
        summary => 'Spelling out a number in English',
    },
    {
        name => 'IPLocation',
        url => 'http://neilb.org/reviews/ip-location.html',
        summary => 'Locating an IP address',
    },
    {
        name => 'Passwords',
        url => 'http://neilb.org/reviews/passwords.html',
        summary => 'Generating passwords',
    },
);

my $ua = LWP::UserAgent->new;
$ua->agent("Mozilla/5.0");

for my $mod (@modules) {
    $log->infof("Processing %s ...", $mod->{name});
    my $cache_path = "$Bin/../devdata/$mod->{name}.html";
    my @st_cache = stat $cache_path;
    my $content;
    if (!@st_cache || $st_cache[9] < $now-30*86400) {
        $log->infof("Retrieving %s ...", $mod->{url});
        my $resp = $ua->get($mod->{url});
        $resp->is_success or die "Can't get $mod->{url}: ".$resp->status_line;
        $content = $resp->content;
        write_text($cache_path, $content);
    } else {
        $log->infof("Using cache file %s", $cache_path);
        $content = read_text($cache_path);
    }

    my $dom = DOM::Tiny->new($content);
    my %mods;
    for my $link ($dom->find('a[href]')->each) {
        #say $link;
        my $url = $link->attr->{href};
        my $m = extract_module_from_cpan_url($url);
        next unless $m;
        $log->debugf("  found module: %s", $m);
        $mods{$m}++;
    }

    my $module_path = "$Bin/../lib/Acme/CPANLists/Import/NEILB/$mod->{name}.pm";

    my $mod_list = {
        summary => $mod->{summary},
        entries => [map {+{module=>$_}} sort keys %mods],
    };

    my @pm_content = (
        "package Acme::CPANLists::Import::NEILB::$mod->{name};\n",
        "\n",
        "# DATE\n",
        "# VERSION\n",
        "\n",
        "our \@Module_Lists = (", dmp($mod_list), ");\n",
        "\n",
        "1;\n",
        "# ABSTRACT: $mod->{summary}\n",
        "\n",
        "=head1 DESCRIPTION\n",
        "\n",
        "This module is generated by extracting module names mentioned in the article L<$mod->{url}>. For the full article, visit the URL.\n",
        "\n",
    );

    $log->infof("Writing module %s ...", $module_path);
    write_text($module_path, join("", @pm_content));
}
